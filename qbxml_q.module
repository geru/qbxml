<?php
// $Id$
// namespace Drupal\qbwc_interface;
// use Drupal\qbwc_interface;

require_once 'qbxml_q.inc';

/**
 * @file
 * QB XML test module
 */

/**
 * Implements hook_menu().
 */
function qbxml_q_menu() {
  $MENU_ENTERPRISE = 'admin/enterprise';

  $items[$MENU_ENTERPRISE] = array(
    'title' => 'Enterprise',
    'description' => 'Enterprise configuration',
    'weight' => -8,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    // 'position' => 'right',
  );
  $items[$MENU_ENTERPRISE . '/qb'] = array(
    'title' => 'Quickbooks',
    'description' => 'Quickbooks interface and importing',
    'weight' => -8,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    // 'position' => 'right',
    // 'type' => MENU_NORMAL_ITEM,
  );

  $items[$MENU_ENTERPRISE . '/qb/qbxml'] = array(
    'title' => 'QBXML',
    'description' => 'QBXML functionality',
    'weight' => -8,
    // Page callback, etc. need to be added here.
    'page callback' => 'system_admin_menu_block_page',
    // we should implement this function in system.admin.inc file
    'access arguments' => array('access administration pages'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    // don't forget to add the file and path
    // 'position' => 'right',
    // 'type' => MENU_NORMAL_ITEM,
  );
  $items[$MENU_ENTERPRISE . '/qb/qbxml/admin'] = array(
    'title' => 'QBXML Q admin',
    'description' => 'qbxml_q management configuration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('qbxml_q_admin_settings_form'),
    'access arguments' => array('access administration pages'),
    'file' => 'qbxml_q.admin.inc',
    'file path' => drupal_get_path('module', 'qbxml_q'),
    // 'type' ='position' => 'right',
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}


/**
 * Implements hook_help().
 */
function qbxml_q_help($path, $arg) {
  switch ($path) {
    case 'admin/settings/qbxml_q':
      return t('Configure the message queue directory for QBXML Queue module.');

    case 'admin/help#qbxml_q':
      $output = '<p>' . t('This is help text for the qbxml_q help page') . '</p>';
      return $output;
  }
    return FALSE;
}

/**
 * Implements hook_hook_info();
 */
function qbwml_q_hook_info() {
  $hooks[ HOOK_QBXML_Q_PREPROCESS ] = array( 'group' => 'qbxml_q' );
  $hooks[ HOOK_QBXML_Q_PROCESS_INCOMING ] = array( 'group' => 'qbxml_q' );
  return( $hooks );
}

/*
 * qbxml_q's uri to store files in
 */
function _qbxml_q_get_furi()
{ $furi = variable_get( QBXML_Q_FURI, 'private://qbxml_q' );
  if( !file_prepare_directory($furi, FILE_MODIFY_PERMISSIONS | FILE_CREATE_DIRECTORY) ) {
    $furi = "private://";
    variable_set( QBXML_Q_FURI, $furi );
  }
  return( $furi . '/' );
}


/**
 * Implements hook_qbwc_sendRequestXML().
function qbxml_q_qbwc_sendRequestXML($ticket=NULL, $company=NULL, $strCompanyFileName,
                                         $qbXMLCountry, $qbXMLMajorVers, $qbXMLMinorVers) {
  $ret = NULL;
  if( $ticket ) {
    $queue = DrupalQueue::get(QBXML_Q_OUT, TRUE);
    if( $item = $queue->claimItem() ) {
      $ret = $item->data;
      $queue->deleteItem($item);
    }
  }
  return $ret ? $ret : '';
}
 * */

function _qbxml_q_set_sendtime( $rid ) {
  db_update( 'qbxml_q' )
    ->fields(array('gid' => $rid ))
    ->condition( 'rid', $rid )
    ->execute();
  $num = db_update( 'qbxml_q' )
    ->fields(array('sent' => REQUEST_TIME ))
    ->condition( 'gid', $rid )
    ->execute();
  return $num;
}

/*
 * Implements hook_qbwc_sendRequestXML()
 */
function qbxml_q_qbwc_sendRequestXML($bookid, $sendRequestXML, $company) {
  $ret = NULL;

  $files = _qbxml_q_filename( $bookid, '(\pN+)', 'q' );
  $matchpattern = '/' . basename($files) . '/';
  $outfiles = file_scan_directory( dirname($files), $matchpattern );
  foreach( $outfiles as $absolute => $filename ) {
    if( file_exists($absolute) ) {
      $handle = fopen($absolute, "r");
      $ret = fread($handle, filesize($absolute));
      fclose($handle);
      file_unmanaged_delete($absolute);
      preg_match( $matchpattern, $filename->filename, $matches );
      _qbxml_q_set_sendtime( $matches[1] );
      break;
    }
  }
  return $ret;
}


/**
 * Formats XML elements.
 *
 * @param $array
 *   An array where each item represents an element and is either a:
 *   - (key => value) pair (<key>value</key>)
 *   - Associative array with fields:
 *     - 'key': element name
 *     - 'value': element contents
 *     - 'attributes': associative array of element attributes
 *     - 'encoded': TRUE if 'value' is already encoded
 *
 * In both cases, 'value' can be a simple string, or it can be another array
 * with the same format as $array itself for nesting.
 *
 * If 'encoded' is TRUE it is up to the caller to ensure that 'value' is either
 * entity-encoded or CDATA-escaped. Using this option is not recommended when
 * working with untrusted user input, since failing to escape the data
 * correctly has security implications.
 */
function qbxml_q_format_xml_elements($array) {
  $output = '';
  foreach ($array as $key => $value) {
    if (is_numeric($key)) {
      if ($value['key']) {
        $output .= '<' . $value['key'];
        if (isset($value['attributes']) && is_array($value['attributes'])) {
          $output .= drupal_attributes($value['attributes']);
        }

        if (isset($value['value']) && $value['value'] != '') {
          $output .= '>' . (is_array($value['value']) ? format_xml_elements($value['value']) : (!empty($value['encoded']) ? $value['value'] : check_plain($value['value']))) . '</' . $value['key'] . ">\n";
        }
        else {
          $output .= " />\n";
        }
      }
    }
    else {
      $output .= '<' . $key . '>' . (is_array($value) ? format_xml_elements($value) : $value) . "</$key>\n";
    }
  }
  return $output;
}

/*
 * Implements hook_qbwc_receiveResponseXML().
 */
function qbxml_q_qbwc_receiveResponseXML($bookid, $response = NULL, $company) {
  // $queue_out = DrupalQueue::get(QBXML_Q_OUT, TRUE);
  $ret = 100;
  if (!$response) {
    watchdog('QBXML_Q', 'ReceiveResponse no response returning 0');
  }
  else {

    if ($response->hresult) {
      // error has happened and is described in hresult and message
      // @todo: enact error recovery for specific use cases
    }
    else {
      $ret = qbxml_q_import($bookid, $response->response);
    }
  }
  return ($ret);
  // return( $queue_out->numberOfItems() ? 20 : 100 );
}

/*
 * Generate a filename to spec
*/
function _qbxml_q_filename( $bookid, $id, $type, $ext = 'xml' ) {
  return( _qbxml_q_get_furi() . $bookid . '-' . $id . '_R' . $type . '.' . $ext );
}


/*
 * Delete saved request file archive and database entry after successful response has been received
*/
function qbxml_q_deleterequest( $bookid, $requestID ) {
  db_delete('qbxml_q')->condition('rid', $requestID)->condition('bookid', $bookid)->execute();
}

/*
 * Worker function to process incoming QBXML responses
 * returns percent complete
 */
function qbxml_q_import( $bookid, $response ) {
  $groupowner = NULL;
  if( $qbxml_info = simplexml_load_string($response) ) { // use PHP builtin extension libxml
    foreach ($qbxml_info->QBXMLMsgsRs->children() as $responsenode) {
      $item = new stdClass();

      $item->node = $responsenode;
      $item->name = $responsenode->getname();
      $item->requestID = $responsenode['requestID'];
      $source = db_select( 'qbxml_q', 'q' )
        ->condition( 'q.bookid', $bookid)
        ->condition( 'q.rid', $item->requestID )
        ->fields( 'q' )
        ->execute()
        ->fetchObject();
      // $source = db_query( "SELECT * FROM {qbxml_q} WHERE rid = :requestID", array( ':requestID' => $item->requestID ) )->fetchObject();
      if( !$source ) {
        watchdog( 'QPROC_IN', 'Unexpected incoming requestID ' . $item->requestID . '' );
        continue;
      }
      $groupowner = $source->gid;
      $item->request = json_decode($source->request);

      // send to hook that does generic processing
      if (sizeof(module_implements(QBXML_Q_HOOK_PREPROCESS)) > 0) {
        // Call all modules that implement the hook, and let them make changes to $responsenode.
        if (implode('', module_invoke_all(QBXML_Q_HOOK_PREPROCESS, $bookid, $item->node))) {
          qbxml_q_deleterequest( $bookid, $item->requestID );
          continue; // hook functions should only return something if they have claimed the data.
        }
      }

      // send to predetermined, targetted processor hook
      $callback = isset($item->request['#attributes']['callback']) ? $item->request['#attributes']['callback'] : array( 'importer' => 'qbxml_q', 'params' => '' );
      $userfunc = $callback['importer'] . '_' . HOOK_QBXML_Q_IMPORT;
      if ($ret = call_user_func($userfunc, $bookid, $item)) {
        qbxml_q_deleterequest( $bookid, $item->requestID );
        continue;
      }
//      watchdog( 'QPROC_Q', 'about to invoke rules event' );
      // if processing gets to this point, the node has not been processed
      // todo: save to file?
      // if( !$queue_in ) {
//        $queue_in = DrupalQueue::get(QBXML_Q_IN, TRUE);
//      }
//      $nonprocesseditem->name = $name;
//      $queue_in->createItem($response); // it is possible to someday put incoming items into a queue to be processed by cron
//      rules_invoke_event(QBXML_Q_EVENT_IN, $requestID, $name, $responsenode, $callback_params);

      watchdog( 'QPROC_IN', "didn't die" );
      $filename = _qbxml_q_filename( $bookid, $item->requestID, 's', 'json' );
      $item->request['#attributes']['bookid'] = $bookid;
//      file_unmanaged_save_data($item->asXML(), $filename);
      file_unmanaged_save_data(json_encode($item), $filename);
      // send to hook that does generic processing
      if (sizeof(module_implements(QBXML_Q_HOOK_FILEPROCESS)) > 0) {
        // Call all modules that implement the hook, and let them deal with the file
        if (implode('', module_invoke_all(QBXML_Q_HOOK_FILEPROCESS, $filename)) ) {
          qbxml_q_deleterequest( $bookid, $item->requestID );
          continue; // hook functions should only return something if they have claimed the data.
        }
      }
      qbxml_q_deleterequest( $bookid, $item->requestID );
    }
  }
  $recsleft = db_select( 'qbxml_q', 'q' )
    ->condition( 'q.gid', $groupowner)
    ->fields( 'q' )
    ->execute()
    ->rowCount();
  $percentdone = (int) 100 / ($recsleft + 1);
  return (int) $percentdone ? (int) $percentdone : (int) 1;
}


/*
 * Implements hook_feeds_after_import()
 */
function qbxml_q_feeds_after_import(FeedsSource $source) {
  watchdog( 'POST_IMPORT', 'source=' . _var_dump2str($source) );
  if (isset($source->exception)) {
    watchdog( 'POST_IMPORT', 'exception=' . _var_dump2str($source->exception) );
      watchdog('QBXML_Q', 'An exception occurred during importing!');
  }
  else {
    $class = get_class($source->importer->fetcher);
    if ($class == 'FeedsFileFetcher') {
      if (strpos($source->id, QBXML_Q_FEEDS_PREFIX) !== FALSE) {
        $filename = $source->getConfig()[ 'FeedsFileFetcher' ][ 'source' ];
        file_unmanaged_delete($filename);
      }
    }
  }
}


/*
 * Implements hook qbxml_q_import
 */
function qbxml_q_qbxml_q_import( $bookid, $item ){
  if( !$item ) {
    return( FALSE );
  }

  $targetfeedid = isset( $item->request['#attributes']['callback']['params'] ) ? $item->request['#attributes']['callback']['params'] : QBXML_Q_FEEDS_PREFIX;
  $targetfeedid .= strtolower($item->name);
  if( isset(_feeds_importer_digest()[$targetfeedid]) && ($source = feeds_source( $targetfeedid )) ) {
    if( $source->importer->fetcher->hasSourceConfig() ) {
      $class = get_class($source->importer->fetcher);
      if ($class == 'FeedsFileFetcher') {
        // $fetcherconfig = $source->importer->fetcher->getConfig();
        $sourceconfig = $source->getConfig();

        $filename = _qbxml_q_filename( $bookid, $item->requestID, 's' );
        $sourceconfig[ 'FeedsFileFetcher' ][ 'source' ] = $filename;
        $item->node->attributes->bookid = $bookid;
        file_unmanaged_save_data($item->node->asXML(), $filename);
        $source->importer->addConfig( array( 'process_in_background' => TRUE ) );
        $source->setConfig($sourceconfig);

        $source->startImport();
        // while( FEEDS_BATCH_COMPLETE != $source->import() ); // use this to process if process_in_background not set above
        return (TRUE);
      }
    }
  }
  // Didn't process
  return( FALSE );
}

/*
 * Store a single request in database and return its newly found ID number
 * Request is timestamped and serialized
*/
function _qbxml_q_stash_request( $bookid, $groupID, $type, $request ) {
  return(
  db_insert('qbxml_q')
    ->fields( array(
        'bookid' => $bookid,
        'gid' => $groupID,
        'type' => $type,
        'created' => REQUEST_TIME,
        'request' => json_encode($request),
      ) )->execute()
  );
}

/*
 * Store a single request on disk with requestID in the filename
*/
function _qbxml_q_write_xml_file( $bookid, $type, $reqarray ) {
  file_unmanaged_save_data( qbxml_q_format_xml_elements($reqarray), _qbxml_q_filename( $bookid, $reqarray[0]['value']['0']['attributes']['requestID'], $type ) );
}

/*
 * Implement the action to take an array of QBXMLMsgsRq, and put them into the QBXML send Q
 * attach callback information.
 *   Input parameter $QBXMLMsgsRqs must be an array of XML renderable queries. Eg.
 *   $QBXMLMsgsRqs = array(
 *     array(
 *       'key' => 'QBXMLMsgsRq',
 *       'attributes' => array( 'onError' => 'continueOnError', ),
 *       'value' => array(
 *         'key' => 'CustomerQueryRq',
 *         'value' => '<IncludeRetElement>FullName</IncludeRetElement>' ),
 *         // attributes always have a requestID, but this is generated by qbxml_q and should not be passed in
 *         // Some queries like AccountQueryRqType have additional attributes which will be preserved.
 *       'encoded' => TRUE,
 *     ),
 *     array(
 *
 *  );
 */
function qbxml_q_action_add_render_array_to_out_queue( $bookid, $QBXMLMsgsRqs ) {
  foreach( $QBXMLMsgsRqs as &$QBXMLMsgsRq ) { // possible, though unlikely, to have multiple QBXMLMSGSRq grouped in one request
    foreach( $QBXMLMsgsRq['value'] as &$request ) {
      // put into database
      $request['encoded'] = TRUE;
      $request['#attributes'] = array(
        'parentattributes' => $QBXMLMsgsRq['attributes'],
        'groupparent' => isset($QBXMLMsgsRq['value'][0]['requestID']) ? $QBXMLMsgsRq['value'][0]['requestID'] : 0,
        'callback' => isset($QBXMLMsgsRq['value'][0]['#callback']) ? $QBXMLMsgsRq['value'][0]['#callback'] : array( 'importer' => 'qbxml_q', 'params' => '' ),
      );
      if( isset( $request['#callback'])) {
        unset( $request['#callback']);
      }
        // $xmlstr = qbxml_q_format_xml_elements($request);
      $request['attributes']['requestID'] = _qbxml_q_stash_request( $bookid, $request['#attributes']['groupparent'], 'q', $request );
    }
  }
  // $QBXMLMsgsRqs['encoded'] = TRUE;
  _qbxml_q_write_xml_file( $bookid, 'q', $QBXMLMsgsRqs );
}
